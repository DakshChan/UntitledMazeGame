import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

/**
 * Generates a maze by random using recursive backtracking
 */
public class MazeGenerator {
	// height and width of the maze to generate
	final static int HEIGHT = 19;
	final static int WIDTH = 19;

	// an enum of possible directions that the backtracking algorithm couol take could take
	enum Directions {
		UP,
		DOWN,
		LEFT,
		RIGHT
	}

	// where the actual maze is saved
	float[][] maze = new float[HEIGHT][WIDTH];

	/**
	 * Constructor for the client. Gets the maze from the server
	 * @param maze the maze that is already generated by the server
	 */
	MazeGenerator(float[][] maze) {
		this.maze = maze;
	}

	/**
	 * Constructor for the server. Generates a random maze.
	 */
	MazeGenerator() {
		// Create a grid with 0 representing a wall, 1 representing an empty cell, and 0.5 representing visited cells
		for(int i = 0; i < HEIGHT; i++) {
			for(int j = 0; j < WIDTH; j++) {
				if (i % 2 == 1 || j % 2 == 1) {
					maze[i][j] = 0;
				}
				if (i == 0 || i == HEIGHT - 1 || j == 0 || j == WIDTH - 1) {
					maze[i][j] = 0.5f;
				}
			}
		}

		// an even random number from 2 to WIDTH - 2 exclusive
		Random random = new Random();
		int sx = 2 + random.nextInt((WIDTH - 4) / 2) * 2; // random starting x coordinates
		int sy = 2 + random.nextInt((HEIGHT - 4) / 2) * 2; // random starting y coordinates
		generator(sx, sy, maze);

		// change all the visited cells back to empty cells
		for (int i = 0; i < HEIGHT; i++) {
			for (int j = 0; j < WIDTH; j++) {
				if (maze[i][j] == 0.5f) {
					maze[i][j] = 1.0f;
				}
			}
		}

		// add an exit
		maze[HEIGHT - 2][WIDTH - 3] = 1.0f;


		// Generate a random item 4 times
		for (int i = 0; i<4; i++) {
			boolean isBlank = false;
			while (!isBlank) {
				int randX = 2 + random.nextInt((WIDTH - 4) / 2) * 2;
				int randY = 2 + random.nextInt((HEIGHT - 4) / 2) * 2;
				if (maze[randX][randY] == 1.0f) {
					isBlank = true;
					maze[randX][randY] = 2.0f;
				}
			}
		}

	}

	private void generator(int cx, int cy, float[][] grid) {
		// mark the current cell as visited
		grid[cy][cx] = 0.5f;

		Random random = new Random();

		if (grid[cy - 2][cx] == 0.5f && grid[cy + 2][cx] == 0.5f && grid[cy][cx - 2] == 0.5f && grid[cy][cx + 2] == 0.5f) { // if all directions have been visited
			// has no where to go
		} else {
			ArrayList<Directions> directions = new ArrayList<>(Arrays.asList(Directions.UP, Directions.DOWN, Directions.LEFT, Directions.RIGHT));
			while (directions.size() > 0) { // base case when all 4 directions have been visited
				// pick a random direction and go to that new cell
				Directions direction = directions.get(random.nextInt(directions.size()));
				directions.remove(direction);

				int ny, nx, my, mx;

				if (direction == Directions.UP) {
					ny = cy - 2;
					my = cy - 1;
				} else if (direction == Directions.DOWN) {
					ny = cy + 2;
					my = cy + 1;
				} else {
					ny = cy;
					my = cy;
				}

				if (direction == Directions.LEFT) {
					nx = cx - 2;
					mx = cx - 1;
				} else if (direction == Directions.RIGHT) {
					nx = cx + 2;
					mx = cx + 1;
				} else {
					nx = cx;
					mx = cx;
				}

				// if the new cell is not already visited, carve a wall and recursively do the same until all cells have been visited
				if (grid[ny][nx] != 0.5f) {
					grid[my][mx] = 0.5f;
					generator(nx, ny, grid);
				}
				// if cell is already visited, choose another direction
			}
		}
	}

	// print a string representation of the maze. DEBUG ONLY
	/*public void showMaze() {
		for (int i = 0; i < HEIGHT; i++) {
			for (int j = 0; j < WIDTH; j++) {
				System.out.print(maze[i][j] + " ");
			}
			System.out.println("");
		}
	}*/

	// convert the maze into an int representation to be parsed
	public int[][] getMaze() {
		int[][] intMaze = new int[WIDTH -2][HEIGHT-2];
		for (int i = 1; i < HEIGHT - 1; i++) {
			for (int j = 1; j < WIDTH - 1; j++) {
				if ((int)maze[i][j] == 1) {
					intMaze[i-1][j-1] = 0;
				} else if ((int)maze[i][j] == 0) {
					intMaze[i-1][j-1] = 1;
				} else {
					intMaze[i-1][j-1] = 2;
				}
			}
		}
		return intMaze;
	}

	/**
	 * Parses the maze into a string that can be sent
	 * @param maze a 2d array representation of the maze
	 * @return a String representation of the maze
	 */
	public static String parseMaze(float[][] maze) {
		String str = "";

		for (int i = 0; i < MazeGenerator.HEIGHT; i++) {
			for (int j = 0; j < MazeGenerator.WIDTH; j++) {
				if (maze[i][j] == 1.0f) {
					str += "1";
				} else if (maze[i][j] == 2.0f){
					str += "2";
				} else {
					str += "0";
				}
			}
			str +="l";
		}

		return str;
	}

}
